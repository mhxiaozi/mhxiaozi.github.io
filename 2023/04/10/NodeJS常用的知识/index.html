<!DOCTYPE html><html lang="zh-CH" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>NodeJS常用的知识 | mhxiaozi'blog</title><meta name="author" content="mhxiaozi"><meta name="copyright" content="mhxiaozi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="背压问题在 Node.js 中，背压（Back Pressure）问题是指在数据流处理中，当数据生产速度大于数据消费速度时，导致消费者无法及时处理数据，从而积累了大量未处理的数据。这种情况可能会导致内存消耗过大，应用程序性能下降，甚至崩溃。 背压问题通常出现在以下情况： 1.可读流和可写流的速度不匹配：当可读流产生数据比可写流消耗数据的速度快时，数据将积累在内存中，导致内存泄漏和性能问题。 2.高">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJS常用的知识">
<meta property="og:url" content="https://github.com/mhxiaozi/mhxiaozi.github.io/2023/04/10/NodeJS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="mhxiaozi&#39;blog">
<meta property="og:description" content="背压问题在 Node.js 中，背压（Back Pressure）问题是指在数据流处理中，当数据生产速度大于数据消费速度时，导致消费者无法及时处理数据，从而积累了大量未处理的数据。这种情况可能会导致内存消耗过大，应用程序性能下降，甚至崩溃。 背压问题通常出现在以下情况： 1.可读流和可写流的速度不匹配：当可读流产生数据比可写流消耗数据的速度快时，数据将积累在内存中，导致内存泄漏和性能问题。 2.高">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-04-10T09:01:01.000Z">
<meta property="article:modified_time" content="2024-02-02T09:13:58.277Z">
<meta property="article:author" content="mhxiaozi">
<meta property="article:tag" content="NodeJS,学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/mhxiaozi/mhxiaozi.github.io/2023/04/10/NodeJS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NodeJS常用的知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-02-02 17:13:58'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 有关</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="mhxiaozi'blog"><span class="site-name">mhxiaozi'blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 有关</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NodeJS常用的知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-04-10T09:01:01.000Z" title="Created 2023-04-10 17:01:01">2023-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-02T09:13:58.277Z" title="Updated 2024-02-02 17:13:58">2024-02-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Node-js/">Node.js</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>15mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NodeJS常用的知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="背压问题"><a href="#背压问题" class="headerlink" title="背压问题"></a>背压问题</h2><p>在 Node.js 中，背压（Back Pressure）问题是指在数据流处理中，当数据生产速度大于数据消费速度时，导致消费者无法及时处理数据，从而积累了大量未处理的数据。这种情况可能会导致内存消耗过大，应用程序性能下降，甚至崩溃。</p>
<p>背压问题通常出现在以下情况：</p>
<h3 id="1-可读流和可写流的速度不匹配："><a href="#1-可读流和可写流的速度不匹配：" class="headerlink" title="1.可读流和可写流的速度不匹配："></a>1.<strong>可读流和可写流的速度不匹配</strong>：</h3><p>当可读流产生数据比可写流消耗数据的速度快时，数据将积累在内存中，导致内存泄漏和性能问题。</p>
<h3 id="2-高速网络请求和慢速响应："><a href="#2-高速网络请求和慢速响应：" class="headerlink" title="2.高速网络请求和慢速响应："></a>2.<strong>高速网络请求和慢速响应</strong>：</h3><p>在网络编程中，如果客户端发送请求的速度远快于服务器响应的速度，服务器可能会积累大量未处理的请求，从而导致拥塞和延迟。</p>
<h3 id="3-数据生产者和数据消费者之间的速度不匹配："><a href="#3-数据生产者和数据消费者之间的速度不匹配：" class="headerlink" title="3.数据生产者和数据消费者之间的速度不匹配："></a>3.<strong>数据生产者和数据消费者之间的速度不匹配</strong>：</h3><p>这可以是任何生产者-消费者模型，包括消息队列、数据流处理等。当生产者生成数据的速度快于消费者处理数据的速度时，背压问题就会出现。</p>
<h2 id="解决背压问题"><a href="#解决背压问题" class="headerlink" title="解决背压问题"></a>解决背压问题</h2><p>为了解决背压问题，Node.js 提供了一些机制和模块，例如：</p>
<ul>
<li><strong>流（Streams）</strong>：Node.js 提供了可读流和可写流，它们允许在处理数据时逐块传输数据，从而降低内存使用并提高性能。通过监听流的<code>data</code>事件，您可以按需处理数据，而不是将所有数据加载到内存中。</li>
<li><strong>流控制</strong>：Node.js 中的流控制模块如 <code>stream.Readable</code> 和 <code>stream.Writable</code> 具有内置的背压机制，它们可以自动控制数据的传输速度，以避免积累大量未处理的数据。</li>
<li><strong>使用合适的缓冲区大小</strong>：在数据流传输过程中，可以通过调整缓冲区的大小来控制数据的传输速度。这有助于确保消费者能够及时处理数据，而不会积累太多未处理的数据。</li>
<li><strong>流控制库</strong>：一些第三方库和模块也可以帮助处理背压问题，例如 <code>highland.js</code> 和 <code>rxjs</code>。</li>
</ul>
<p>解决背压问题是设计高性能和可伸缩的 Node.js 应用程序的重要部分。通过正确地管理数据流和使用适当的流控制机制，可以确保应用程序在高负载下稳定运行。</p>
<h2 id="GET-请求与-POST-请求"><a href="#GET-请求与-POST-请求" class="headerlink" title="GET 请求与 POST 请求"></a>GET 请求与 POST 请求</h2><p>GET 请求和 POST 请求是两种最常见的 HTTP 请求方法，用于<strong>与服务器进行通信</strong>，但它们用于不同的目的和方式：</p>
<h3 id="1-GET-请求："><a href="#1-GET-请求：" class="headerlink" title="1.GET 请求："></a>1.<strong>GET 请求</strong>：</h3><ul>
<li>GET 请求用于从服务器<strong>获取数据</strong>。它通常是一种“读取”操作，用于请求服务器返回特定资源的信息。</li>
<li>GET 请求的参数通常包含在请求的 <strong>URL</strong> 中，以查询字符串的形式发送给服务器。例如，<code>http://example.com/api/data?id=123</code> 中的 <code>id=123</code> 就是一个 GET 请求的参数。</li>
<li>GET 请求是<strong>幂等</strong>的，这意味着多次执行相同的 GET 请求应该产生相同的结果，并且不应该对服务器状态产生任何影响。</li>
<li>GET 请求通常用于<strong>获取</strong>网页、图片、文档等静态资源，也可以用于执行一些<strong>只读操作</strong>，如搜索或过滤数据。</li>
</ul>
<h3 id="2-POST-请求："><a href="#2-POST-请求：" class="headerlink" title="2.POST 请求："></a>2.<strong>POST 请求</strong>：</h3><ul>
<li>POST 请求用于向服务器<strong>提交数据</strong>，通常是一种“写入”或“更新”操作，用于创建、更新或删除资源。</li>
<li>POST 请求的参数通常包含在请求的<strong>请求体</strong>中，而不是在 URL 中。这意味着 POST 请求可以用于传递大量数据，而不会受到 URL 长度限制。</li>
<li>POST 请求<strong>不是幂等</strong>的，即多次执行相同的 POST 请求可能会导致不同的结果，例如创建多个相同的资源。</li>
<li>POST 请求通常用于<strong>提交</strong>表单数据、上传文件、执行登录操作、进行支付等需要<strong>传递敏感数据或执行修改操作</strong>的场景。</li>
</ul>
<p>总结来说，GET 请求用于获取数据，通常不对服务器状态产生影响，并且参数包含在 URL 中。而 POST 请求用于向服务器提交数据，通常用于创建、更新或删除资源，并且参数包含在请求体中。在实际应用中，选择使用 GET 还是 POST 取决于您的<strong>需求</strong>和<strong>安全性</strong>考虑。例如，对于不应该被缓存的请求或需要传递大量数据的请求，通常使用 POST 请求。</p>
<h2 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h2><p><code>Promise</code> 构造函数用于创建一个新的 Promise 对象，该对象表示一个<strong>异步操作</strong>的结果。它接受一个带有两个参数的回调函数，通常称为执行器函数（executor function）。执行器函数会在 Promise 对象被创建时立即执行，并接受两个参数，通常称为 <code>resolve</code> 和 <code>reject</code>，它们是两个函数，用于表示 Promise 的最终状态是<strong>成功（resolved）</strong>还是<strong>失败（rejected）</strong>。</p>
<p>以下是 <code>Promise</code> 构造函数的<strong>基本用法</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 执行异步操作，例如请求数据、读取文件等</span></span><br><span class="line">  <span class="comment">// 当操作成功完成时，调用 resolve 并传递结果</span></span><br><span class="line">  <span class="comment">// resolve(&#x27;成功的结果&#x27;);</span></span><br><span class="line">  <span class="comment">// 当操作失败时，调用 reject 并传递错误信息</span></span><br><span class="line">  <span class="comment">// reject(new Error(&#x27;操作失败&#x27;));</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，您可以将异步操作（例如数据请求或文件读取）放入执行器函数中，并根据操作结果调用 <code>resolve</code> 或 <code>reject</code> 函数。</p>
<p>一旦创建了一个 Promise 实例，您可以使用 <code>then()</code> 和 <code>catch()</code> 方法来处理 Promise 的成功和失败情况，如前面的回答所示。</p>
<p>请注意，<code>Promise</code> 是 JavaScript 中用于<strong>管理异步操作</strong>的强大工具，它可以帮助您更好地<strong>管理异步代码处理成功和失败</strong>的情况。了解如何正确使用 <code>Promise</code> 对于处理异步任务非常重要。</p>
<h2 id="cath-与-then"><a href="#cath-与-then" class="headerlink" title="cath()与 then()"></a>cath()与 then()</h2><p><code>catch()</code> 和 <code>then()</code> 是两个用于处理 JavaScript Promise 的方法。它们用于<strong>处理 Promise</strong> 在执行过程中的不同状态，主要是成功（resolved）和失败（rejected）。</p>
<h3 id="1-then-方法："><a href="#1-then-方法：" class="headerlink" title="1.then() 方法："></a>1.<strong>then() 方法</strong>：</h3><ul>
<li><code>then()</code> 方法用于处理 Promise <strong>成功状态</strong>（resolved）时的情况。</li>
<li><code>then()</code> 方法接受<strong>两个回调函数</strong>作为参数，第一个回调函数用于处理成功的情况，第二个回调函数用于处理失败的情况（可选）。</li>
<li>如果 Promise <strong>成功被解决</strong>，第一个回调函数将被执行，并将成功的结果作为参数传递给它。</li>
<li>如果 Promise <strong>被拒绝</strong>被拒绝，第二个回调函数（如果存在）将被执行，并将拒绝的原因（通常是一个错误对象）作为参数传递给它。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理成功的情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise resolved with result:&quot;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理失败的情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Promise rejected with error:&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-catch-方法："><a href="#2-catch-方法：" class="headerlink" title="2.catch() 方法："></a>2.<strong>catch() 方法</strong>：</h3><ul>
<li><code>catch()</code> 方法是用于处理 Promise <strong>失败状态</strong>（rejected）时的情况的方法。</li>
<li><code>catch()</code> 方法只接受<strong>一个回调函数</strong>作为参数，用于处理拒绝的原因。</li>
<li>它通常位于 <code>then()</code> 方法链的<strong>末尾</strong>，用于捕获整个 Promise 链中的任何拒绝情况。</li>
<li><code>catch()</code> 方法的主要优势在于它使<strong>错误处理更集中</strong>，避免了在每个 <code>then()</code> 方法中都重复编写错误处理代码。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理成功的情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise resolved with result:&quot;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理失败的情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Promise rejected with error:&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>总结来说，<code>then()</code> 方法用于处理 Promise 成功情况，而 <code>catch()</code> 方法用于处理 Promise 失败情况。它们一起构成了 Promise 的链式操作，使您能够更好地处理异步代码中的成功和失败情况。根据具体的需求，您可以选择在 <code>then()</code> 方法中处理失败情况，或者在 <code>catch()</code> 方法中集中处理。通常，<code>catch()</code> 方法用于全局的错误处理，而 <code>then()</code> 方法用于特定成功情况的处理。</p>
<h2 id="async-与-await"><a href="#async-与-await" class="headerlink" title="async 与 await"></a>async 与 await</h2><p><code>async</code> 和 <code>await</code> 是 JavaScript 中处理异步操作的现代方式。它们使异步代码更加清晰和易于理解，避免了回调地狱（Callback Hell）和复杂的 Promise 链。</p>
<h3 id="1-async-函数："><a href="#1-async-函数：" class="headerlink" title="1.async 函数："></a>1.<strong>async 函数</strong>：</h3><ul>
<li><code>async</code> 关键字用于定义一个异步函数，它将返回一个 Promise 对象。</li>
<li>异步函数内部可以包含 <code>await</code> 表达式，用于暂停函数的执行，直到 Promise 被解决为止。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">someAsyncFunction</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-await-表达式："><a href="#2-await-表达式：" class="headerlink" title="2.await 表达式："></a>2.<strong>await 表达式</strong>：</h3><ul>
<li><code>await</code> 关键字用于等待一个 Promise 被解决。它只能在异步函数内部使用。</li>
<li>当 <code>await</code> 表达式执行时，函数将暂停执行，直到 Promise 被解决或拒绝。</li>
<li>如果 Promise 被解决，<code>await</code> 表达式将返回解决值；如果 Promise 被拒绝，它将抛出一个异常。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 等待异步操作完成</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">someAsyncFunction</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred:&quot;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-async-await-的好处："><a href="#3-async-await-的好处：" class="headerlink" title="3.async&#x2F;await 的好处："></a>3.<strong>async&#x2F;await 的好处</strong>：</h3><ul>
<li>使异步代码看起来更像同步代码，更易于理解和维护。</li>
<li>可以使用 <code>try...catch</code> 来捕获和处理异步操作中的错误。</li>
<li>避免了回调地狱，使代码更加扁平和可读。</li>
</ul>
<h3 id="4-使用注意事项："><a href="#4-使用注意事项：" class="headerlink" title="4.使用注意事项："></a>4.<strong>使用注意事项</strong>：</h3><ul>
<li><code>await</code> 只能在异步函数内部使用。如果尝试在非异步函数中使用 <code>await</code>，会导致语法错误。</li>
<li>异步函数总是返回一个 Promise，无论它是否包含 <code>await</code> 表达式。</li>
<li><code>await</code> 只能等待 Promise 对象，如果传递给它的是非 Promise 值，它会自动将其包装成 Promise。</li>
</ul>
<p>下面是一个示例，演示了如何使用 <code>async</code> 和 <code>await</code> 来处理异步操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="title function_">fetchDataFromAPI1</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Data from API 1:&quot;</span>, data1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">fetchDataFromAPI2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Data from API 2:&quot;</span>, data2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> finalData = <span class="title function_">combineData</span>(data1, data2);</span><br><span class="line">    <span class="keyword">return</span> finalData;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred:&quot;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Final result:&quot;</span>, result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Outer error:&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>fetchData()</code> 函数是一个异步函数，它使用 <code>await</code> 来等待两个不同的异步操作完成，然后将它们的结果组合起来。如果任何异步操作失败，它会捕获错误并抛出异常。最后，我们使用 <code>.then()</code> 和 <code>.catch()</code> 来处理异步函数的结果和错误。</p>
<h2 id="try…catch-语句"><a href="#try…catch-语句" class="headerlink" title="try…catch 语句"></a>try…catch 语句</h2><p><code>try...catch</code> 语句是 JavaScript 中用于<strong>异常处理的机制</strong>，它允许您在代码中<strong>捕获</strong>和<strong>处理</strong>运行时发生的<strong>错误</strong>或<strong>异常</strong>。<code>try...catch</code> 语句由两部分组成：<code>try</code> 块和 <code>catch</code> 块。</p>
<ol>
<li><strong>try 块</strong>：在 <code>try</code> 块中，您可以放置可能会引发异常的代码。如果在 <code>try</code> 块中的代码<strong>发生异常</strong>，控制流会<strong>立即跳转</strong>到 <code>catch</code> 块，而 <code>try</code> 块中<strong>剩余的代码不会执行</strong>。</li>
<li><strong>catch 块</strong>：<code>catch</code> 块用于<strong>捕获并处理异常</strong>。在 <code>catch</code> 块中，您可以访问异常对象并执行与异常相关的操作，如记录错误、向用户显示消息、回滚事务等。通常，<code>catch</code> 块中的代码用于处理异常情况，并采取适当的措施来处理错误。</li>
</ol>
<p>以下是 <code>try...catch</code> 语句的基本语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 可能会引发异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 异常处理代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 尝试执行可能引发异常的代码</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="number">10</span> / <span class="number">0</span>; <span class="comment">// 这会引发一个除以零的错误</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 不会执行到这里</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 处理异常</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred:&quot;</span>, error.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，由于试图除以零，会引发一个异常，然后控制流跳转到 <code>catch</code> 块，打印出错误消息。</p>
<p><code>try...catch</code> 语句是一种优雅的方式来<strong>处理运行时错误</strong>，可以帮助您编写更健壮的代码，防止错误导致程序崩溃。它还可以用于处理异步代码中的错误，例如 Promise 的 <code>catch</code> 方法或异步函数中的错误捕获。</p>
<h2 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h2><p><code>throw</code> 是 JavaScript 中用于抛出异常的关键字。它通常用于在代码中发现错误或不正常情况时引发异常，以便进一步处理或中断程序的执行。</p>
<p>使用 <code>throw</code> 时，您可以抛出一个任意的值，通常是一个包含错误信息的字符串或一个错误对象。这个值将作为异常的描述信息传递到异常处理程序，然后可以在捕获异常的地方进行处理。</p>
<p>以下是 <code>throw</code> 的基本用法示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;Division by zero is not allowed&quot;</span>; <span class="comment">// 抛出一个字符串异常</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Result:&quot;</span>, result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred:&quot;</span>, error); <span class="comment">// 捕获并处理异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>divide</code> 函数尝试执行除法操作，如果除数 <code>b</code> 为零，就会抛出一个字符串异常。然后，我们使用 <code>try...catch</code> 语句来捕获并处理异常。在 <code>catch</code> 块中，我们可以访问抛出的异常，以便进行进一步的处理。</p>
<p>通常情况下，建议使用 Error 对象来抛出异常，而不是字符串，因为 Error 对象可以提供更多的错误信息和调试信息。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Division by zero is not allowed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">divide</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Result:&quot;</span>, result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;An error occurred:&quot;</span>, error.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 <code>throw new Error()</code> 来抛出一个 Error 对象，它包含了错误信息。然后，我们在 <code>catch</code> 块中使用 <code>error.message</code> 访问错误消息。这样可以提供更多的错误信息，有助于调试和识别问题。</p>
<h2 id="arguments-内置对象"><a href="#arguments-内置对象" class="headerlink" title="arguments 内置对象"></a>arguments 内置对象</h2><p><code>arguments</code> 是一个特殊的内置对象，它在 JavaScript 函数中自动创建，并包含了函数被调用时传递的参数列表。<code>arguments</code> 对象允许您访问传递给函数的参数，无论您是否在函数定义中显式声明了这些参数。</p>
<p>以下是关于 <code>arguments</code> 对象的一些重要信息和用法：</p>
<h3 id="1-arguments-对象的基本用法："><a href="#1-arguments-对象的基本用法：" class="headerlink" title="1.arguments 对象的基本用法："></a>1.<strong><code>arguments</code> 对象的基本用法</strong>：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction example(a, b) &#123;</span><br><span class="line">    console.log(arguments[0]); // 访问第一个参数</span><br><span class="line">    console.log(arguments[1]); // 访问第二个参数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1, 2);</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>arguments</code> 对象包含了被传递给 <code>example</code> 函数的参数，即 <code>1</code> 和 <code>2</code>。</p>
<h3 id="2-arguments-对象的长度属性："><a href="#2-arguments-对象的长度属性：" class="headerlink" title="2.arguments 对象的长度属性："></a>2.<strong><code>arguments</code> 对象的长度属性</strong>：</h3><p><code>arguments</code> 对象有一个 <code>length</code> 属性，表示传递给函数的参数数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction example() &#123;</span><br><span class="line">    console.log(arguments.length); // 参数数量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1, 2, 3);</span><br><span class="line">// 输出:</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>

<h3 id="3-arguments-对象的迭代："><a href="#3-arguments-对象的迭代：" class="headerlink" title="3.arguments 对象的迭代："></a>3.<strong><code>arguments</code> 对象的迭代</strong>：</h3><p>您可以使用 <code>for</code> 循环或其他迭代方法遍历 <code>arguments</code> 对象中的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction example() &#123;</span><br><span class="line">    for (let i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        console.log(arguments[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1, 2, 3);</span><br><span class="line">// 输出:</span><br><span class="line">// 1</span><br><span class="line">// 2</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>

<h3 id="4-转为数组："><a href="#4-转为数组：" class="headerlink" title="4.转为数组："></a>4.<strong>转为数组</strong>：</h3><p>虽然 <code>arguments</code> 对象类似于数组，但它并不是真正的数组。您可以将它转换为一个真正的数组，以便使用数组方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction example() &#123;</span><br><span class="line">    const argsArray = Array.from(arguments);</span><br><span class="line">    console.log(argsArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1, 2, 3);</span><br><span class="line">// 输出: [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="5-使用剩余参数："><a href="#5-使用剩余参数：" class="headerlink" title="5.使用剩余参数："></a>5.<strong>使用剩余参数</strong>：</h3><p>在现代 JavaScript 中，通常更推荐使用剩余参数（Rest Parameters）来处理不定数量的函数参数，而不是依赖于 <code>arguments</code> 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codefunction example(...args) &#123;</span><br><span class="line">    console.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1, 2, 3);</span><br><span class="line">// 输出: [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>arguments</code> 对象在箭头函数中不可用，因为箭头函数没有自己的 <code>arguments</code> 对象，它会继承外部函数的 <code>arguments</code> 对象（如果有的话）。因此，如果需要在箭头函数中使用参数列表，通常使用剩余参数或者传递参数为参数。</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p><code>super</code> 是一个关键字，通常用于在派生类（子类）中调用父类的构造函数和方法。在面向对象编程中，它用于实现继承和在子类中重用父类的功能。</p>
<p><code>super</code> 可以用于两个主要的方面：</p>
<h3 id="1-调用父类构造函数："><a href="#1-调用父类构造函数：" class="headerlink" title="1.调用父类构造函数："></a>1.<strong>调用父类构造函数</strong>：</h3><p>在子类的构造函数中使用 <code>super()</code> 调用父类的构造函数。这是为了确保子类在实例化时能够执行父类的构造逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeclass Parent &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    constructor(name, age) &#123;</span><br><span class="line">        super(name); // 调用父类的构造函数</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const child = new Child(&quot;Alice&quot;, 5);</span><br><span class="line">console.log(child.name); // 输出 &quot;Alice&quot;</span><br><span class="line">console.log(child.age);  // 输出 5</span><br></pre></td></tr></table></figure>

<h3 id="2-调用父类方法："><a href="#2-调用父类方法：" class="headerlink" title="2.调用父类方法："></a>2.<strong>调用父类方法</strong>：</h3><p>在子类的方法中使用 <code>super.methodName()</code> 调用父类的方法。这允许子类重写父类的方法，但仍然能够在子类中访问父类的实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascriptCopy codeclass Parent &#123;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return &quot;Hello from parent&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        return super.greet() + &quot; and child&quot;; // 调用父类的方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const child = new Child();</span><br><span class="line">console.log(child.greet()); // 输出 &quot;Hello from parent and child&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>super</code> 关键字用于确保子类构造函数中的父类构造函数得到调用，以便正确地初始化父类和子类的属性。同时，<code>super.methodName()</code> 用于在子类方法中调用父类方法，以便子类可以扩展或修改父类方法的行为。</p>
<p>请注意，<code>super</code> 的使用方式可能会有所不同，具体取决于编程语言和类的实现方式。在 ES6 的 JavaScript 中，<code>super</code> 通常用于以上两种情况。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://github.com/mhxiaozi/mhxiaozi.github.io">mhxiaozi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://github.com/mhxiaozi/mhxiaozi.github.io/2023/04/10/NodeJS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86/">https://github.com/mhxiaozi/mhxiaozi.github.io/2023/04/10/NodeJS%E5%B8%B8%E7%94%A8%E7%9A%84%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/NodeJS-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">NodeJS,学习笔记</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/03/05/HTTP%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="HTTP基本知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-05</div><div class="title">HTTP基本知识</div></div></a></div><div><a href="/2023/02/20/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8npm%E5%AE%89%E8%A3%85%E5%8C%85%E5%8D%A1%E9%A1%BF%E6%96%B9%E6%B3%95/" title="解决使用npm安装包卡顿方法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">解决使用npm安装包卡顿方法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mhxiaozi</div><div class="author-info__description">与其期待明天，不如过好今天</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" href="https://github.com/mhxiaozi"><i class="fab fa-github"></i><span>作者</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/mhxiaozi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3075701775@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">背压问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%AF%E8%AF%BB%E6%B5%81%E5%92%8C%E5%8F%AF%E5%86%99%E6%B5%81%E7%9A%84%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">1.可读流和可写流的速度不匹配：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E9%80%9F%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E6%85%A2%E9%80%9F%E5%93%8D%E5%BA%94%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">2.高速网络请求和慢速响应：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B6%88%E8%B4%B9%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%8C%B9%E9%85%8D%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3.数据生产者和数据消费者之间的速度不匹配：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%83%8C%E5%8E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">解决背压问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E8%AF%B7%E6%B1%82%E4%B8%8E-POST-%E8%AF%B7%E6%B1%82"><span class="toc-number">3.</span> <span class="toc-text">GET 请求与 POST 请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GET-%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">1.GET 请求：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-POST-%E8%AF%B7%E6%B1%82%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">2.POST 请求：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">Promise 构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cath-%E4%B8%8E-then"><span class="toc-number">5.</span> <span class="toc-text">cath()与 then()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-then-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">1.then() 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-catch-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">2.catch() 方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-%E4%B8%8E-await"><span class="toc-number">6.</span> <span class="toc-text">async 与 await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-async-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">1.async 函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-await-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">2.await 表达式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-async-await-%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9A"><span class="toc-number">6.3.</span> <span class="toc-text">3.async&#x2F;await 的好处：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">6.4.</span> <span class="toc-text">4.使用注意事项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try%E2%80%A6catch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">7.</span> <span class="toc-text">try…catch 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.</span> <span class="toc-text">throw 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">9.</span> <span class="toc-text">arguments 内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-arguments-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">1.arguments 对象的基本用法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-arguments-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%95%BF%E5%BA%A6%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">2.arguments 对象的长度属性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-arguments-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%AD%E4%BB%A3%EF%BC%9A"><span class="toc-number">9.3.</span> <span class="toc-text">3.arguments 对象的迭代：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AC%E4%B8%BA%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">9.4.</span> <span class="toc-text">4.转为数组：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">5.使用剩余参数：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">10.</span> <span class="toc-text">super 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">10.1.</span> <span class="toc-text">1.调用父类构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">2.调用父类方法：</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2024 By mhxiaozi</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="24" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>